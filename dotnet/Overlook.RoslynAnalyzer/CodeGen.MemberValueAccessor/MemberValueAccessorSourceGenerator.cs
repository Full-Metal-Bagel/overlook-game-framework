using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.MemberValueAccessor;

[SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking")]
[Generator]
public class MemberValueAccessorSourceGenerator : IIncrementalGenerator
{
    // Define diagnostic descriptor
    private readonly DiagnosticDescriptor s_notPublicMemberDiagnostic = new(
        id: "MVA001",
        title: "Member must be public",
        messageFormat: "Member '{0}' with MemberValueAccessor attribute must be public",
        category: "MemberValueAccessor",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var fieldProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is FieldDeclarationSyntax field && HasAttributeOf(field, "MemberValueAccessor"),
                (ctx, _) => (Field: (FieldDeclarationSyntax)ctx.Node, ctx.SemanticModel)
            ).Select((t, _) => t);

        var propertyProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is PropertyDeclarationSyntax property && HasAttributeOf(property, "MemberValueAccessor"),
                (ctx, _) => (Property: (PropertyDeclarationSyntax)ctx.Node, ctx.SemanticModel)
            ).Select((t, _) => t);

        context.RegisterSourceOutput(fieldProvider.Collect(), GenerateFieldAccessorCode);
        context.RegisterSourceOutput(propertyProvider.Collect(), GeneratePropertyAccessorCode);
        return;

        static bool HasAttributeOf(MemberDeclarationSyntax node, string attributeName)
        {
            return node.AttributeLists.SelectMany(al => al.Attributes).Any(attribute => attribute.Name.ToString() == attributeName);
        }
    }

    private void GenerateFieldAccessorCode(SourceProductionContext context, ImmutableArray<(FieldDeclarationSyntax Field, SemanticModel SemanticModel)> fields)
    {
        var code = new StringBuilder("// <auto-generated/>");
        code.AppendLine();
        code.AppendLine("namespace Game.Gen.MemberValueAccessor");
        code.AppendLine("{");

        foreach (var (field, semanticModel) in fields)
        {
            if (!field.IsPublic())
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    s_notPublicMemberDiagnostic,
                    field.GetLocation(),
                    field.GetName()));
                continue;
            }

            var declaringType = field.GetDeclaringTypeFullName();
            var valueType = field.GetTypeFullName(semanticModel);
            var setter = field.IsReadOnly() ? $"throw new System.{nameof(System.NotSupportedException)}()" : $"declaring.{field.GetName()} = value";
            var guid = field.GetGuid();
            if (!string.IsNullOrEmpty(guid)) code.AppendLine($"[TypeGuid({guid})]");
            code.AppendLine($$"""
                              public readonly struct {{field.GetDeclaringTypeName()}}_{{field.GetName()}} : Game.IMemberValueAccessor<{{declaringType}}, {{valueType}}>
                              {
                                  public {{valueType}} GetValue({{declaringType}} declaring) => declaring.{{field.GetName()}};
                                  public void SetValue({{declaringType}} declaring, {{valueType}} value) => {{setter}};
                              }

                              """);
        }

        code.AppendLine("}");
        context.AddSource("FieldValueAccessor.g.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private void GeneratePropertyAccessorCode(SourceProductionContext context, ImmutableArray<(PropertyDeclarationSyntax Property, SemanticModel SemanticModel)> properties)
    {
        var code = new StringBuilder("// <auto-generated/>");
        code.AppendLine();
        code.AppendLine("namespace Game.Gen.MemberValueAccessor");
        code.AppendLine("{");

        foreach (var (property, semanticModel) in properties)
        {
            if (!property.IsPublic())
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    s_notPublicMemberDiagnostic,
                    property.GetLocation(),
                    property.GetName()));
                continue;
            }

            var declaringType = property.GetDeclaringTypeFullName();
            var valueType = property.GetTypeFullName(semanticModel);
            var getter = property.HasPublicGetMethod() ? $"declaring.{property.GetName()}" : $"throw new System.{nameof(System.NotSupportedException)}()";
            var setter = property.HasPublicSetMethod() ? $"declaring.{property.GetName()} = value" : $"throw new System.{nameof(System.NotSupportedException)}()";
            var guid = property.GetGuid();
            if (!string.IsNullOrEmpty(guid)) code.AppendLine($"[TypeGuid({guid})]");
            code.AppendLine($$"""
                              public readonly struct {{property.GetDeclaringTypeName()}}_{{property.GetName()}} : Game.IMemberValueAccessor<{{declaringType}}, {{valueType}}>
                              {
                                  public {{valueType}} GetValue({{declaringType}} declaring) => {{getter}};
                                  public void SetValue({{declaringType}} declaring, {{valueType}} value) => {{setter}};
                              }

                              """);
        }

        code.AppendLine("}");
        context.AddSource("PropertyValueAccessor.g.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }
}
