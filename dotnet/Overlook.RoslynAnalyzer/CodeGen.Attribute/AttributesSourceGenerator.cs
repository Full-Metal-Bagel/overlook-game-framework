using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.Attribute;

[Generator]
public class AttributesSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            ExecuteImpl(context);
        }
        catch (Exception ex)
        {
            var exception = Diagnostic.Create(new DiagnosticDescriptor("AR0000", "invalid attribute", $"exception: {ex}", "ATTR", DiagnosticSeverity.Error, true), null);
            context.ReportDiagnostic(exception);
        }
    }

    private void ExecuteImpl(GeneratorExecutionContext context)
    {
        var nodes = ((SyntaxContextReceiver)context.SyntaxReceiver!).Nodes;
        if (nodes.Count == 0)
        {
            return;
        }

        var source = new StringBuilder("""
                                       // <auto-generated/>
                                       """);

        // TODO: verify node
        var validNodes = new List<TypeDeclarationSyntax>();
        foreach (var node in nodes)
        {
            var guid = FindTypeGuid(node);
            var hasPartial = node.Modifiers.Any(m => m.ValueText == "partial");
            if (string.IsNullOrEmpty(guid) && !hasPartial) continue;

            if (!hasPartial)
            {
                var noPartial = Diagnostic.Create(new DiagnosticDescriptor("AR0001", "invalid attribute", $"attribute {node.Identifier.ToString()} must be `partial` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noPartial);
                continue;
            }

            if (GetImplementedInterfaceNames(node).Any(interfaceName => interfaceName != "IAttribute`1"))
            {
                var invalidInterface = Diagnostic.Create(new DiagnosticDescriptor("AR0003", "invalid attribute", $"attribute {node.Identifier.ToString()} must be implement `IAttribute<T>` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(invalidInterface);
                continue;
            }

            if (string.IsNullOrEmpty(guid))
            {
                var noGuid = Diagnostic.Create(new DiagnosticDescriptor("AR0002", "invalid attribute", $"attribute {node.Identifier.ToString()} must have `TypeGuidAttribute` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noGuid);
                continue;
            }
            validNodes.Add(node);
        }

        var idType = validNodes.Count switch
        {
            <= byte.MaxValue => "byte",
            <= ushort.MaxValue => "ushort",
            _ => "int"
        };

        foreach (var node in validNodes)
        {
            source.AppendLine();
            var fieldCount = node.Members.Count(IsValidMember);
            if (fieldCount == 0) GenerateNonFieldAttribute(node);
            else if (fieldCount == 1) GenerateSingleFieldAttribute(node);
            else GenerateMultipleFieldAttribute(node);
        }

        context.AddSource("Attributes.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        return;

        bool HasConstructor(TypeDeclarationSyntax node)
        {
            return node.Members.OfType<ConstructorDeclarationSyntax>().Any();
        }

        bool IsValidMember(MemberDeclarationSyntax member)
        {
            return member is FieldDeclarationSyntax or PropertyDeclarationSyntax;
        }

        void GenerateNonFieldAttribute(TypeDeclarationSyntax node)
        {
            var typeName = node is StructDeclarationSyntax ? "struct" : "class";
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                              public partial {{typeName}} {{structName}}
                              {
                              {{AttributeBasic(structName: structName, guid: guid)}}
                              }
                              """);
        }

        string FindTypeGuid(TypeDeclarationSyntax node)
        {
            var guidAttribute = node.AttributeLists.SelectMany(a => a.Attributes).SingleOrDefault(attribute => attribute.Name.ToString() == "TypeGuid");
            return guidAttribute == null ? "" : guidAttribute.ArgumentList!.Arguments[0].ToString();
        }

        string AttributeBasic(string structName, string guid)
        {
            return $$"""
                         public static System.Guid AttributeTypeGuid { get; } = System.Guid.Parse({{guid}});
                         public static ushort StorageTypeId { get; } = RelEcs.StorageType.Create<{{structName}}>();
                     """;
        }

        string Equatable(string structName, params string[] fields)
        {
            var equals = string.Join(" && ", fields.Select(name => $"{name}.Equals(other.{name})"));
            return $$"""
                        public bool Equals({{structName}} other) => {{equals}};
                        public override bool Equals(object obj) => obj is {{structName}} other && Equals(other);
                        public override int GetHashCode() => System.HashCode.Combine({{string.Join(", ", fields)}});
                        public static bool operator ==({{structName}} left, {{structName}} right)
                        {
                            return left.Equals(right);
                        }
                        public static bool operator !=({{structName}} left, {{structName}} right)
                        {
                            return !(left == right);
                        }
                     """;
        }

        (string name, string type) GetMemberNameAndType(MemberDeclarationSyntax member) => member switch
        {
            FieldDeclarationSyntax field => (field.Declaration.Variables.First().Identifier.Text, field.Declaration.Type.ToString()),
            PropertyDeclarationSyntax property => (property.Identifier.ToString(), property.Type.ToString()),
            _ => ("", "")
        };

        void GenerateSingleFieldAttribute(TypeDeclarationSyntax node)
        {
            var typeName = node is StructDeclarationSyntax ? "struct" : "class";
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            var (fieldName, fieldType) = node.Members
                .Where(IsValidMember)
                .Select(GetMemberNameAndType)
                .Single(t => !string.IsNullOrEmpty(t.name))
            ;
            var constructor = HasConstructor(node) ? "" : $"public {structName}({fieldType} value) => {fieldName} = value;";
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                              [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1066:Implement IEquatable when overriding Object.Equals")]
                              public partial {{typeName}} {{structName}}
                              {
                              {{AttributeBasic(structName: structName, guid: guid)}}

                                  {{constructor}}
                                  public static implicit operator {{fieldType}}({{structName}} data) => data.{{fieldName}};
                                  public static explicit operator {{structName}}({{fieldType}} value) => new(value);

                              {{Equatable(structName, fieldName)}}
                              }
                              """);
        }

        void GenerateMultipleFieldAttribute(TypeDeclarationSyntax node)
        {
            var typeName = node is StructDeclarationSyntax ? "struct" : "class";
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            var fieldsNameAndType = node.Members.Where(IsValidMember).Select(GetMemberNameAndType).Where(t => !string.IsNullOrEmpty(t.name)).ToArray();
            var fieldsName = fieldsNameAndType.Select(t => t.name).ToArray();
            var fieldsPublicName = fieldsName.Select(name => name.TrimStart('_')).Select(name => char.ToLower(name[0]) + name.Substring(1)).ToArray();
            var fieldsType = fieldsNameAndType.Select(t => t.type).ToArray();
            var fieldsTuple = string.Join(", ", fieldsPublicName.Zip(fieldsType, (name, type) => $"{type} {name}"));
            var fieldsAssignment = string.Join("; ", fieldsName.Zip(fieldsPublicName, (name, publicName) => (name, publicName)).Select(t => $"{t.name} = {t.publicName}"));
            var deconstructParameters = string.Join(",", fieldsPublicName.Zip(fieldsType, (name, type) => $"out {type} {name}"));
            var deconstructBody = fieldsName.Zip(fieldsPublicName, (name, publicName) => $"        {publicName} = {name};");
            var constructor = HasConstructor(node) ? "" : $"public {structName}({fieldsTuple}) {{ {fieldsAssignment}; }}";
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                                [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1066:Implement IEquatable when overriding Object.Equals")]
                                public partial {{typeName}} {{structName}}
                                {
                                {{AttributeBasic(structName: structName, guid: guid)}}
                                    {{constructor}}
                                    public void Deconstruct({{deconstructParameters}})
                                    {
                                """);

            foreach (var body in deconstructBody) source.AppendLine(body);

            source.AppendLine($$"""
                                    }

                                {{Equatable(structName, fieldsName)}}
                                }
                                """);
        }
    }

    // https://chat.openai.com/share/f70c449a-6956-41cc-a7bc-2cc7799b2d4b
    private IEnumerable<string> GetImplementedInterfaceNames(TypeDeclarationSyntax typeDeclaration)
    {
        if (typeDeclaration.BaseList != null)
        {
            foreach (var baseType in typeDeclaration.BaseList.Types)
            {
                // Check if the base type is an interface
                if (baseType is SimpleBaseTypeSyntax simpleBaseType)
                {
                    var type = simpleBaseType.Type;

                    if (type is IdentifierNameSyntax identifierName)
                    {
                        yield return identifierName.Identifier.Text;
                    }
                    else if (type is QualifiedNameSyntax qualifiedName)
                    {
                        yield return qualifiedName.Right.Identifier.Text;
                    }
                }
            }
        }
    }

    struct NamespaceNameScope : IDisposable
    {
        private readonly bool _hasNamespace;
        private readonly StringBuilder _builder;

        public NamespaceNameScope(StringBuilder builder, TypeDeclarationSyntax node)
        {
            var namespaceNode = node.Ancestors()
                .OfType<NamespaceDeclarationSyntax>()
                .FirstOrDefault();

            _hasNamespace = namespaceNode != null;
            _builder = builder;

            if (namespaceNode != null)
            {
                builder.AppendLine($"namespace {namespaceNode.Name}");
                builder.AppendLine("{");
            }
        }

        public void Dispose()
        {
            if (_hasNamespace) _builder.AppendLine("}");
        }
    }

    private sealed class SyntaxContextReceiver : ISyntaxReceiver
    {
        public HashSet<TypeDeclarationSyntax> Nodes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is TypeDeclarationSyntax typeNode)
            {
                if (typeNode.BaseList == null) return;
                // TODO: restrict to `Game.IAttribute` or `Game.IAttribute<T>`
                if (typeNode.BaseList.Types.Select(type => type.ToString()).All(type => !type.Contains("IAttribute"))) return;
                Nodes.Add(typeNode);
            }
        }
    }
}
