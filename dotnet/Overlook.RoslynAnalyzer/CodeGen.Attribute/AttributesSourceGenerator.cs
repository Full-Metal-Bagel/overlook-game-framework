using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.Attribute;

[Generator]
public class AttributesSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            ExecuteImpl(context);
        }
        catch (Exception ex)
        {
            ReportDiagnostic(context, DiagnosticDescriptors.ExceptionDescriptor, null, ex.ToString());
        }
    }

    private void ExecuteImpl(GeneratorExecutionContext context)
    {
        var nodes = ((SyntaxContextReceiver)context.SyntaxReceiver!).Nodes;
        if (nodes.Count == 0)
        {
            return;
        }

        var source = new StringBuilder("""
                                       // <auto-generated/>
                                       """);

        // TODO: verify node
        var validNodes = new List<TypeDeclarationSyntax>();
        foreach (var node in nodes)
        {
            var guid = FindTypeGuid(node);
            var hasPartial = node.Modifiers.Any(m => m.ValueText == "partial");
            if (string.IsNullOrEmpty(guid) && !hasPartial) continue;

            var attributeName = node.Identifier.ToString();
            if (!hasPartial)
            {
                ReportDiagnostic(context, DiagnosticDescriptors.NoPartialDescriptor, node, attributeName);
                continue;
            }

            if (GetAttributeValueType(node) == null)
            {
                ReportDiagnostic(context, DiagnosticDescriptors.InvalidInterfaceDescriptor, node, attributeName);
                continue;
            }

            if (string.IsNullOrEmpty(guid))
            {
                ReportDiagnostic(context, DiagnosticDescriptors.NoGuidDescriptor, node, attributeName);
                continue;
            }

            var nodeKind = node.Kind();
            if (nodeKind is not SyntaxKind.RecordDeclaration and not SyntaxKind.RecordStructDeclaration)
            {
                ReportDiagnostic(context, DiagnosticDescriptors.NotRecordTypeDescriptor, node, attributeName);
                continue;
            }
            validNodes.Add(node);
        }

        foreach (var node in validNodes)
        {
            source.AppendLine();
            GenerateSingleFieldAttribute(node);
        }

        context.AddSource("Attributes.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        return;

        static TypeSyntax? GetAttributeValueType(TypeDeclarationSyntax node)
        {
            if (node.BaseList == null)
                return null;

            foreach (BaseTypeSyntax baseType in node.BaseList.Types)
            {
                if (baseType is SimpleBaseTypeSyntax { Type: GenericNameSyntax { Identifier.Text: "IAttribute" } genericName })
                {
                    return genericName.TypeArgumentList.Arguments.FirstOrDefault();
                }
            }
            return null;
        }

        void GenerateSingleFieldAttribute(TypeDeclarationSyntax node)
        {
            var kind = node.Kind();
            var typeName = kind switch
            {
                SyntaxKind.RecordDeclaration => "record class",
                SyntaxKind.RecordStructDeclaration => "record struct",
                SyntaxKind.StructDeclaration => "struct",
                SyntaxKind.ClassDeclaration => "class",
                _ => throw new InvalidOperationException()
            };
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            var attributeValueType = GetAttributeValueType(node)!;
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                              {{string.Join(" ", node.Modifiers)}} {{typeName}} {{structName}}
                              {
                              {{AttributeBasic(structName: structName, guid: guid)}}
                              """);
            if (kind is SyntaxKind.RecordDeclaration or SyntaxKind.ClassDeclaration && !HasDefaultConstructor(node))
            {
                source.AppendLine($"    public {structName}() {{ }}");
            }

            if (!HasValueConstructor(node, attributeValueType))
            {
                source.AppendLine($"    public {structName}({attributeValueType} value) : this() => Value = value;");
            }

            if (kind is SyntaxKind.StructDeclaration or SyntaxKind.ClassDeclaration)
            {
                source.AppendLine(Equatable(structName));
            }

            var property = node.Members.OfType<PropertyDeclarationSyntax>().Single(property => property.Identifier.ToString() == "Value");
            var semanticModel = context.Compilation.GetSemanticModel(node.SyntaxTree);
            var isInterfaceField = semanticModel.GetTypeInfo(property.Type).Type?.TypeKind == TypeKind.Interface;
            if (!isInterfaceField)
            {
                source.AppendLine($$"""
                                      public static implicit operator {{attributeValueType}}({{structName}} data) => data.Value;
                                      public static explicit operator {{structName}}({{attributeValueType}} value) => new {{structName}}(value);
                                  """);
            }
            source.AppendLine("}");
        }

        static bool HasDefaultConstructor(TypeDeclarationSyntax node)
        {
            return node.Members.OfType<ConstructorDeclarationSyntax>().Any(ctor => !ctor.ParameterList.Parameters.Any());
        }

        static bool HasValueConstructor(TypeDeclarationSyntax node, TypeSyntax valueType)
        {
            return node.Members.OfType<ConstructorDeclarationSyntax>()
                .Any(ctor => ctor.ParameterList.Parameters.Any(param => param.Type!.ToString() == valueType.ToString()))
            ;
        }

        string FindTypeGuid(TypeDeclarationSyntax node)
        {
            var guidAttribute = node.AttributeLists.SelectMany(a => a.Attributes).SingleOrDefault(attribute => attribute.Name.ToString() == "TypeGuid");
            return guidAttribute == null ? "" : guidAttribute.ArgumentList!.Arguments[0].ToString();
        }

        static string Equatable(string structName)
        {
            return $$"""
                         public bool Equals({{structName}} other) => Value.Equals(other.Value);
                         public override bool Equals(object obj) => obj is {{structName}} other && Equals(other);
                         public override int GetHashCode() => Value.GetHashCode();
                         public static bool operator ==({{structName}} left, {{structName}} right)
                         {
                             return left.Equals(right);
                         }
                         public static bool operator !=({{structName}} left, {{structName}} right)
                         {
                             return !(left == right);
                         }
                     """;
        }

        string AttributeBasic(string structName, string guid)
        {
            return $$"""
                         public static System.Guid AttributeTypeGuid { get; } = System.Guid.Parse({{guid}});
                         public static ushort StorageTypeId { get; } = RelEcs.StorageType.Create<{{structName}}>();
                     """;
        }
    }

    static void ReportDiagnostic(GeneratorExecutionContext context, DiagnosticDescriptor descriptor, TypeDeclarationSyntax? node, params object[] messageArgs)
    {
        node ??= ((SyntaxContextReceiver)context.SyntaxReceiver!).Nodes.First();
        var diagnostic = Diagnostic.Create(descriptor, node.GetLocation(), messageArgs);
        context.ReportDiagnostic(diagnostic);
    }

    struct NamespaceNameScope : IDisposable
    {
        private readonly bool _hasNamespace;
        private readonly StringBuilder _builder;

        public NamespaceNameScope(StringBuilder builder, TypeDeclarationSyntax node)
        {
            var namespaceNode = node.Ancestors()
                .OfType<BaseNamespaceDeclarationSyntax>()
                .FirstOrDefault();

            _hasNamespace = namespaceNode != null;
            _builder = builder;

            if (namespaceNode != null)
            {
                builder.AppendLine($"namespace {namespaceNode.Name}");
                builder.AppendLine("{");
            }
        }

        public void Dispose()
        {
            if (_hasNamespace) _builder.AppendLine("}");
        }
    }

    private sealed class SyntaxContextReceiver : ISyntaxReceiver
    {
        public HashSet<TypeDeclarationSyntax> Nodes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is TypeDeclarationSyntax typeNode)
            {
                if (typeNode.BaseList == null) return;
                // TODO: restrict to `Game.IAttribute` or `Game.IAttribute<T>`
                if (typeNode.BaseList.Types.Select(type => type.ToString()).All(type => !type.StartsWith("IAttribute"))) return;
                Nodes.Add(typeNode);
            }
        }
    }
}

public static class DiagnosticDescriptors
{
    public static readonly DiagnosticDescriptor ExceptionDescriptor = new(
        id: "AR0000",
        title: "Invalid attribute",
        messageFormat: "Exception: {0}",
        category: "ATTR",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NoPartialDescriptor = new(
        id: "AR0001",
        title: "Invalid attribute",
        messageFormat: "Attribute {0} must be `partial` for code-gen",
        category: "ATTR",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NoGuidDescriptor = new(
        id: "AR0002",
        title: "Invalid attribute",
        messageFormat: "Attribute {0} must have `TypeGuidAttribute` for code-gen",
        category: "ATTR",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor InvalidInterfaceDescriptor = new(
        id: "AR0003",
        title: "Invalid attribute",
        messageFormat: "Attribute {0} must implement `IAttribute<T>` for code-gen",
        category: "ATTR",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NotRecordTypeDescriptor = new(
        id: "AR0004",
        title: "Invalid attribute",
        messageFormat: "Attribute {0} must be a `record` type",
        category: "ATTR",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}
