using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.Attribute;

[Generator]
public class AttributesSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            ExecuteImpl(context);
        }
        catch (Exception ex)
        {
            var exception = Diagnostic.Create(new DiagnosticDescriptor("AR0000", "invalid attribute", $"exception: {ex}", "ATTR", DiagnosticSeverity.Error, true), null);
            context.ReportDiagnostic(exception);
        }
    }

    private void ExecuteImpl(GeneratorExecutionContext context)
    {
        var nodes = ((SyntaxContextReceiver)context.SyntaxReceiver!).Nodes;
        if (nodes.Count == 0)
        {
            return;
        }

        var source = new StringBuilder("""
                                       // <auto-generated/>
                                       """);

        // TODO: verify node
        var validNodes = new List<TypeDeclarationSyntax>();
        foreach (var node in nodes)
        {
            var guid = FindTypeGuid(node);
            var hasPartial = node.Modifiers.Any(m => m.ValueText == "partial");
            if (string.IsNullOrEmpty(guid) && !hasPartial) continue;

            if (!hasPartial)
            {
                var noPartial = Diagnostic.Create(new DiagnosticDescriptor("AR0001", "invalid attribute", $"attribute {node.Identifier.ToString()} must be `partial` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noPartial);
                continue;
            }

            if (node.BaseList == null || node.BaseList.Types.All(type => !type.ToString().StartsWith("IAttribute<")))
            {
                var invalidInterface = Diagnostic.Create(new DiagnosticDescriptor("AR0003", "invalid attribute", $"attribute {node.Identifier.ToString()} must be implement `IAttribute<T>` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(invalidInterface);
                continue;
            }

            if (string.IsNullOrEmpty(guid))
            {
                var noGuid = Diagnostic.Create(new DiagnosticDescriptor("AR0002", "invalid attribute", $"attribute {node.Identifier.ToString()} must have `TypeGuidAttribute` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noGuid);
                continue;
            }
            validNodes.Add(node);
        }

        var idType = validNodes.Count switch
        {
            <= byte.MaxValue => "byte",
            <= ushort.MaxValue => "ushort",
            _ => "int"
        };

        foreach (var node in validNodes)
        {
            source.AppendLine();
            GenerateSingleFieldAttribute(node);
        }

        context.AddSource("Attributes.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        return;

        bool HasConstructor(TypeDeclarationSyntax node)
        {
            return node.Members.OfType<ConstructorDeclarationSyntax>().Any();
        }

        string FindTypeGuid(TypeDeclarationSyntax node)
        {
            var guidAttribute = node.AttributeLists.SelectMany(a => a.Attributes).SingleOrDefault(attribute => attribute.Name.ToString() == "TypeGuid");
            return guidAttribute == null ? "" : guidAttribute.ArgumentList!.Arguments[0].ToString();
        }

        string AttributeBasic(string structName, string guid)
        {
            return $$"""
                         public static System.Guid AttributeTypeGuid { get; } = System.Guid.Parse({{guid}});
                         public static ushort StorageTypeId { get; } = RelEcs.StorageType.Create<{{structName}}>();
                     """;
        }

        string Equatable(string structName, params string[] fields)
        {
            var equals = string.Join(" && ", fields.Select(name => $"{name}.Equals(other.{name})"));
            return $$"""
                        public bool Equals({{structName}} other) => {{equals}};
                        public override bool Equals(object obj) => obj is {{structName}} other && Equals(other);
                        public override int GetHashCode() => System.HashCode.Combine({{string.Join(", ", fields)}});
                        public static bool operator ==({{structName}} left, {{structName}} right)
                        {
                            return left.Equals(right);
                        }
                        public static bool operator !=({{structName}} left, {{structName}} right)
                        {
                            return !(left == right);
                        }
                     """;
        }

        void GenerateSingleFieldAttribute(TypeDeclarationSyntax node)
        {
            var typeName = node is StructDeclarationSyntax ? "struct" : "class";
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            var property = node.Members.OfType<PropertyDeclarationSyntax>().Single(property => property.Identifier.ToString() == "Value");
            var (fieldName, fieldType) = (property.Identifier.ToString(), property.Type.ToString());
            var constructor = HasConstructor(node) ? "" : $"public {structName}({fieldType} value) => {fieldName} = value;";
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                              [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1066:Implement IEquatable when overriding Object.Equals")]
                              public partial {{typeName}} {{structName}}
                              {
                              {{AttributeBasic(structName: structName, guid: guid)}}

                                  {{constructor}}
                                  public static implicit operator {{fieldType}}({{structName}} data) => data.{{fieldName}};
                                  public static explicit operator {{structName}}({{fieldType}} value) => new(value);

                              {{Equatable(structName, fieldName)}}
                              }
                              """);
        }
    }

    struct NamespaceNameScope : IDisposable
    {
        private readonly bool _hasNamespace;
        private readonly StringBuilder _builder;

        public NamespaceNameScope(StringBuilder builder, TypeDeclarationSyntax node)
        {
            var namespaceNode = node.Ancestors()
                .OfType<BaseNamespaceDeclarationSyntax>()
                .FirstOrDefault();

            _hasNamespace = namespaceNode != null;
            _builder = builder;

            if (namespaceNode != null)
            {
                builder.AppendLine($"namespace {namespaceNode.Name}");
                builder.AppendLine("{");
            }
        }

        public void Dispose()
        {
            if (_hasNamespace) _builder.AppendLine("}");
        }
    }

    private sealed class SyntaxContextReceiver : ISyntaxReceiver
    {
        public HashSet<TypeDeclarationSyntax> Nodes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is TypeDeclarationSyntax typeNode)
            {
                if (typeNode.BaseList == null) return;
                // TODO: restrict to `Game.IAttribute` or `Game.IAttribute<T>`
                if (typeNode.BaseList.Types.Select(type => type.ToString()).All(type => !type.StartsWith("IAttribute"))) return;
                Nodes.Add(typeNode);
            }
        }
    }
}
