using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.Attribute;

[Generator]
public class AttributesSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var nodes = ((SyntaxContextReceiver)context.SyntaxReceiver!).Nodes;
        var source = new StringBuilder("""
                                       // <auto-generated/>
                                       namespace Game
                                       {
                                       """);

        // TODO: verify node
        var validNodes = new List<StructDeclarationSyntax>();
        foreach (var node in nodes)
        {
            if (node.Modifiers.All(m => m.ValueText != "partial")) continue;
            validNodes.Add(node);
        }

        var idType = validNodes.Count switch
        {
            <= byte.MaxValue => "byte",
            <= ushort.MaxValue => "ushort",
            _ => "int"
        };

        var attributeId = 0;
        foreach (var node in validNodes)
        {
            source.AppendLine();
            var fieldCount = node.Members.Count(m => m is FieldDeclarationSyntax);
            if (fieldCount == 0) GenerateNonFieldAttribute(node);
            else if (fieldCount == 1) GenerateSingleFieldAttribute(node);
            else GenerateMultipleFieldAttribute(node);
        }

        source.AppendLine("}");
        context.AddSource("Attributes.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        return;

        void GenerateNonFieldAttribute(StructDeclarationSyntax node)
        {
            var structName = node.Identifier.ValueText;
            source.AppendLine($$"""
                              public partial struct {{structName}}
                              {
                              {{AttributeBasic(structName)}}
                              }
                              """);
        }

        string AttributeBasic(string structName)
        {
            return $$"""
                         public static {{idType}} Id => {{attributeId++}};
                         public static ushort TypeId { get; } = RelEcs.StorageType.Create<{{structName}}>();
                     """;
        }

        string Equatable(string structName, params string[] fields)
        {
            var equals = string.Join(" && ", fields.Select(name => $"{name}.Equals(other.{name})"));
            return $$"""
                        public bool Equals({{structName}} other) => {{equals}};
                        public override bool Equals(object obj) => obj is {{structName}} other && Equals(other);
                        public override int GetHashCode() => System.HashCode.Combine({{string.Join(", ", fields)}});
                        public static bool operator ==({{structName}} left, {{structName}} right)
                        {
                            return left.Equals(right);
                        }
                        public static bool operator !=({{structName}} left, {{structName}} right)
                        {
                            return !(left == right);
                        }
                     """;
        }

        void GenerateSingleFieldAttribute(StructDeclarationSyntax node)
        {
            var structName = node.Identifier.ValueText;
            var field = node.Members.OfType<FieldDeclarationSyntax>().Select(f => f.Declaration).Single();
            var fieldName = field.Variables.First().Identifier.Text;
            var fieldType = field.Type.ToString();
            source.AppendLine($$"""
                              public partial struct {{structName}}
                              {
                              {{AttributeBasic(structName)}}
                                  public static implicit operator {{fieldType}}({{structName}} data) => data.{{fieldName}};
                                  public static explicit operator {{structName}}({{fieldType}} value) => new() { {{fieldName}} = value };

                              {{Equatable(structName, fieldName)}}
                              }
                              """);
        }

        void GenerateMultipleFieldAttribute(StructDeclarationSyntax node)
        {
            var structName = node.Identifier.ValueText;
            var fields = node.Members.OfType<FieldDeclarationSyntax>().Select(f => f.Declaration).ToArray();
            var fieldsName = fields.Select(f => f.Variables.First().Identifier.Text).ToArray();
            var fieldsPublicName = fieldsName.Select(name => name.TrimStart('_'));
            var fieldsType = fields.Select(f => f.Type.ToString());
            var fieldsTuple = string.Join(", ", fieldsPublicName.Zip(fieldsType, (name, type) => $"{type} {name}"));
            var fieldsAssignment = string.Join(", ", fieldsName.Select(name => $"{name} = value.{name.TrimStart('_')}"));
            var deconstructParameters = string.Join(",", fieldsPublicName.Zip(fieldsType, (name, type) => $"out {type} {name}"));
            var deconstructBody = fieldsName.Zip(fieldsPublicName, (name, publicName) => $"        {publicName} = {name};");
            source.AppendLine($$"""
                                public partial struct {{structName}}
                                {
                                {{AttributeBasic(structName)}}
                                    public static implicit operator ({{fieldsTuple}})({{structName}} data) => ({{string.Join(", ", fieldsName.Select(f => $"data.{f}"))}});
                                    public static explicit operator {{structName}}(({{fieldsTuple}}) value) => new() { {{fieldsAssignment}} };
                                    public void Deconstruct({{deconstructParameters}})
                                    {
                                """);

            foreach (var body in deconstructBody) source.AppendLine(body);

            source.AppendLine($$"""
                                    }

                                {{Equatable(structName, fieldsName)}}
                                }
                                """);
        }
    }

    private sealed class SyntaxContextReceiver : ISyntaxReceiver
    {
        public HashSet<StructDeclarationSyntax> Nodes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is not StructDeclarationSyntax structNode) return;
            if (structNode.BaseList == null) return;
            // TODO: restrict to `Game.IAttribute`
            if (structNode.BaseList.Types.All(type => !type.ToString().EndsWith("IAttribute"))) return;
            Nodes.Add(structNode);
        }
    }
}
