using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.Attribute;

[Generator]
public class AttributesSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var nodes = ((SyntaxContextReceiver)context.SyntaxReceiver!).Nodes;
        var source = new StringBuilder("""
                                       // <auto-generated/>
                                       """);

        // TODO: verify node
        var validNodes = new List<StructDeclarationSyntax>();
        foreach (var node in nodes)
        {
            if (node.Modifiers.All(m => m.ValueText != "partial"))
            {
                var noPartial = Diagnostic.Create(new DiagnosticDescriptor("AR0001", "invalid attribute", $"attribute {node.Identifier.ToString()} must be `partial` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noPartial);
                continue;
            }

            if (GetImplementedInterfaceNames(node).Any(interfaceName => interfaceName != "IAttribute`1"))
            {
                var noPartial = Diagnostic.Create(new DiagnosticDescriptor("AR0003", "invalid attribute", $"attribute {node.Identifier.ToString()} must be implement `IAttribute<T>` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noPartial);
                continue;
            }

            if (string.IsNullOrEmpty(FindTypeGuid(node)))
            {
                var noGuid = Diagnostic.Create(new DiagnosticDescriptor("AR0002", "invalid attribute", $"attribute {node.Identifier.ToString()} must have `TypeGuidAttribute` for code-gen", "ATTR", DiagnosticSeverity.Error, true), node.GetLocation());
                context.ReportDiagnostic(noGuid);
                continue;
            }
            validNodes.Add(node);
        }

        var idType = validNodes.Count switch
        {
            <= byte.MaxValue => "byte",
            <= ushort.MaxValue => "ushort",
            _ => "int"
        };

        var attributeId = 0;
        foreach (var node in validNodes)
        {
            source.AppendLine();
            var fieldCount = node.Members.Count(m => m is FieldDeclarationSyntax or PropertyDeclarationSyntax);
            if (fieldCount == 0) GenerateNonFieldAttribute(node);
            else if (fieldCount == 1) GenerateSingleFieldAttribute(node);
            else GenerateMultipleFieldAttribute(node);
        }

        context.AddSource("Attributes.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        return;

        void GenerateNonFieldAttribute(StructDeclarationSyntax node)
        {
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                              public partial struct {{structName}}
                              {
                              {{AttributeBasic(structName: structName, guid: guid)}}
                              }
                              """);
        }

        string FindTypeGuid(TypeDeclarationSyntax node)
        {
            var guidAttribute = node.AttributeLists.SelectMany(a => a.Attributes).SingleOrDefault(attribute => attribute.Name.ToString() == "TypeGuid");
            return guidAttribute == null ? "" : guidAttribute.ArgumentList!.Arguments[0].ToString();
        }

        string AttributeBasic(string structName, string guid)
        {
            return $$"""
                         public static System.Guid AttributeTypeGuid { get; } = System.Guid.Parse({{guid}});
                         public static {{idType}} UnstableShortId => {{attributeId++}};
                         public {{idType}} AttributeId => {{structName}}.UnstableShortId;
                         public static ushort StorageTypeId { get; } = RelEcs.StorageType.Create<{{structName}}>();
                     """;
        }

        string Equatable(string structName, params string[] fields)
        {
            var equals = string.Join(" && ", fields.Select(name => $"{name}.Equals(other.{name})"));
            return $$"""
                        public bool Equals({{structName}} other) => {{equals}};
                        public override bool Equals(object obj) => obj is {{structName}} other && Equals(other);
                        public override int GetHashCode() => System.HashCode.Combine({{string.Join(", ", fields)}});
                        public static bool operator ==({{structName}} left, {{structName}} right)
                        {
                            return left.Equals(right);
                        }
                        public static bool operator !=({{structName}} left, {{structName}} right)
                        {
                            return !(left == right);
                        }
                     """;
        }

        (string name, string type) GetMemberNameAndType(MemberDeclarationSyntax member) => member switch
        {
            FieldDeclarationSyntax field => (field.Declaration.Variables.First().Identifier.Text, field.Declaration.Type.ToString()),
            PropertyDeclarationSyntax property => (property.Identifier.ToString(), property.Type.ToString()),
            _ => ("", "")
        };

        void GenerateSingleFieldAttribute(StructDeclarationSyntax node)
        {
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            var (fieldName, fieldType) = node.Members
                .Select(GetMemberNameAndType)
                .Single(t => !string.IsNullOrEmpty(t.name))
            ;
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                              [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1066:Implement IEquatable when overriding Object.Equals")]
                              public partial struct {{structName}}
                              {
                              {{AttributeBasic(structName: structName, guid: guid)}}

                                  public {{structName}}({{fieldType}} value) => {{fieldName}} = value;
                                  public static implicit operator {{fieldType}}({{structName}} data) => data.{{fieldName}};
                                  public static explicit operator {{structName}}({{fieldType}} value) => new(value);

                              {{Equatable(structName, fieldName)}}
                              }
                              """);
        }

        void GenerateMultipleFieldAttribute(StructDeclarationSyntax node)
        {
            var structName = node.Identifier.ValueText;
            var guid = FindTypeGuid(node);
            var fieldsNameAndType = node.Members.Select(GetMemberNameAndType).Where(t => !string.IsNullOrEmpty(t.name)).ToArray();
            var fieldsName = fieldsNameAndType.Select(t => t.name).ToArray();
            var fieldsPublicName = fieldsName.Select(name => name.TrimStart('_')).Select(name => char.ToLower(name[0]) + name.Substring(1)).ToArray();
            var fieldsType = fieldsNameAndType.Select(t => t.type).ToArray();
            var fieldsTuple = string.Join(", ", fieldsPublicName.Zip(fieldsType, (name, type) => $"{type} {name}"));
            var fieldsAssignment = string.Join("; ", fieldsName.Zip(fieldsPublicName, (name, publicName) => (name, publicName)).Select(t => $"{t.name} = {t.publicName}"));
            var deconstructParameters = string.Join(",", fieldsPublicName.Zip(fieldsType, (name, type) => $"out {type} {name}"));
            var deconstructBody = fieldsName.Zip(fieldsPublicName, (name, publicName) => $"        {publicName} = {name};");
            using var _ = new NamespaceNameScope(source, node);
            source.AppendLine($$"""
                                [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1066:Implement IEquatable when overriding Object.Equals")]
                                public partial struct {{structName}}
                                {
                                {{AttributeBasic(structName: structName, guid: guid)}}
                                    public {{structName}}({{fieldsTuple}}) { {{fieldsAssignment}}; }
                                    public void Deconstruct({{deconstructParameters}})
                                    {
                                """);

            foreach (var body in deconstructBody) source.AppendLine(body);

            source.AppendLine($$"""
                                    }

                                {{Equatable(structName, fieldsName)}}
                                }
                                """);
        }
    }

    // https://chat.openai.com/share/f70c449a-6956-41cc-a7bc-2cc7799b2d4b
    private IEnumerable<string> GetImplementedInterfaceNames(StructDeclarationSyntax structDeclaration)
    {
        if (structDeclaration.BaseList != null)
        {
            foreach (var baseType in structDeclaration.BaseList.Types)
            {
                // Check if the base type is an interface
                if (baseType is SimpleBaseTypeSyntax simpleBaseType)
                {
                    var type = simpleBaseType.Type;

                    if (type is IdentifierNameSyntax identifierName)
                    {
                        yield return identifierName.Identifier.Text;
                    }
                    else if (type is QualifiedNameSyntax qualifiedName)
                    {
                        yield return qualifiedName.Right.Identifier.Text;
                    }
                }
            }
        }
    }

    struct NamespaceNameScope : IDisposable
    {
        private readonly bool _hasNamespace;
        private readonly StringBuilder _builder;

        public NamespaceNameScope(StringBuilder builder, TypeDeclarationSyntax node)
        {
            var namespaceNode = node.Ancestors()
                .OfType<NamespaceDeclarationSyntax>()
                .FirstOrDefault();

            _hasNamespace = namespaceNode != null;
            _builder = builder;

            if (namespaceNode != null)
            {
                builder.AppendLine($"namespace {namespaceNode.Name}");
                builder.AppendLine("{");
            }
        }

        public void Dispose()
        {
            if (_hasNamespace) _builder.AppendLine("}");
        }
    }

    private sealed class SyntaxContextReceiver : ISyntaxReceiver
    {
        public HashSet<StructDeclarationSyntax> Nodes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is not StructDeclarationSyntax structNode) return;
            if (structNode.BaseList == null) return;
            // TODO: restrict to `Game.IAttribute` or `Game.IAttribute<T>`
            if (structNode.BaseList.Types.Select(type => type.ToString()).All(type => !type.Contains("IAttribute"))) return;
            Nodes.Add(structNode);
        }
    }
}
