#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace CodeGen.GameTimelineEvent
{
    [Generator]
    public class TimelineEventPartialGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

            var eventDataTypes = receiver.EventDataTypes;
            if (eventDataTypes.Count == 0) return;

            GenerateTimelineNodeEventController(context, receiver.EventTypes, eventDataTypes);
        }

        private void GenerateTimelineNodeEventController(GeneratorExecutionContext context, List<string> eventTypes, List<string> eventDataTypes)
        {
            var source = new StringBuilder();
            source.AppendLine("#nullable enable");
            source.AppendLine("// <auto-generated/>");
            source.AppendLine("using System;");
            source.AppendLine("using System.Collections.Generic;");
            source.AppendLine("using UnityEngine;");
            source.AppendLine("using Game;");
            source.AppendLine("using FlowCanvas;");
            source.AppendLine("using ParadoxNotion.Design;");
            source.AppendLine("namespace Game;");
            source.AppendLine();

            source.AppendLine("public sealed partial class TimelineNodeEventController");
            source.AppendLine("{");

            //s_eventTypeLut field
            source.AppendLine($"    private static readonly Dictionary<Type, Type?> s_eventTypeLut = new()");
            source.AppendLine("    {");
            int i = 0;
            foreach (var eventType in eventTypes)
            {
                string valueType = eventDataTypes[i];
                if (!string.IsNullOrEmpty(valueType))
                {
                    source.AppendLine($"        {{ typeof({eventType}), typeof({valueType}) }},");
                }
                else
                {
                    source.AppendLine($"        {{ typeof({eventType}), null }},");
                }
                i++;
            }
            source.AppendLine("    };");

            source.AppendLine();

            //value field
            foreach (var eventType in eventDataTypes)
            {
                if (!string.IsNullOrEmpty(eventType))
                {
                    source.AppendLine($"    private readonly List<{eventType}> _{TitleLower(eventType)}Values = new();");
                }
            }

            //actions field
            i = 0;
            foreach (var eventType in eventTypes)
            {
                string valueType = eventDataTypes[i];
                if (!string.IsNullOrEmpty(valueType))
                {
                    source.AppendLine($"    private readonly Action<{valueType}, int> _{TitleLower(valueType)}Action = null!;");
                }
                else
                {
                    source.AppendLine($"    private readonly Action<int> _emptyAction = null!;");
                }

                i++;
            }

            source.AppendLine();

            //constructor
            source.AppendLine($"     public TimelineNodeEventController()");
            source.AppendLine("     {");
            i = 0;
            foreach (var eventType in eventTypes)
            {
                string valueType = eventDataTypes[i];
                if (!string.IsNullOrEmpty(valueType))
                {
                    source.AppendLine($"        _{TitleLower(valueType)}Action = {TitleUpper(valueType)}EventHandler;");
                }
                else
                {
                    source.AppendLine($"        _emptyAction = EmptyEventHandler;");
                }

                i++;
            }

            source.AppendLine("     }");
            source.AppendLine();

            // PartialBindEvents
            source.AppendLine("    public void PartialBindEvents(Type? valueType, GameTimelinePlayer timelinePlayer, int resourceId, int i)");
            source.AppendLine("    {");
            foreach (var valueType in eventDataTypes)
            {
                if (string.IsNullOrEmpty(valueType))
                {
                    source.AppendLine($"        if(valueType == null)");
                    source.AppendLine($"        {{");
                    source.AppendLine($"           timelinePlayer.Events[resourceId].TryAdd(_events[i].Type!, (_emptyAction, i));");
                    source.AppendLine($"        }}");
                }
                else
                {
                    source.AppendLine($"        if(valueType == typeof({valueType}))");
                    source.AppendLine($"        {{");
                    source.AppendLine($"           timelinePlayer.Events[resourceId].TryAdd(_events[i].Type!, (_{TitleLower(valueType)}Action, i));");
                    source.AppendLine($"        }}");
                    source.AppendLine($"        _{TitleLower(valueType)}Values.Add(default!);");
                }
            }

            source.AppendLine("    }");

            // EventHandler
            foreach (var valueType in eventDataTypes)
            {
                if (string.IsNullOrEmpty(valueType)) continue;
                source.AppendLine();
                source.AppendLine($"    private void {TitleUpper(valueType)}EventHandler({valueType} e,int i)");
                source.AppendLine("    {");
                source.AppendLine($"        _{TitleLower(valueType)}Values[i] = e;");
                source.AppendLine($"        _flowOutputs[i].Call(new Flow());");
                source.AppendLine("    }");
            }

            source.AppendLine();
            source.AppendLine($"    private void EmptyEventHandler(int i)");
            source.AppendLine("    {");
            source.AppendLine($"        _flowOutputs[i].Call(new Flow());");
            source.AppendLine("    }");
            source.AppendLine();

            //PartialAddOutflowAndOutValue
            source.AppendLine("    public void PartialAddOutflowAndOutValue(FlowNode flowNode, string name, int capturedIndex)");
            source.AppendLine("    {");
            source.AppendLine($"        Type? valueType = s_eventTypeLut[_events[capturedIndex].Type!];");

            foreach (var valueType in eventDataTypes)
            {
                if (!string.IsNullOrEmpty(valueType))
                {
                    source.AppendLine($"        if(valueType == typeof({valueType}))");
                    source.AppendLine($"        {{");
                    source.AppendLine($"           _valueOutputs.Add(flowNode.AddValueOutput($\"{{name}}value\", () => _{TitleLower(valueType)}Values[capturedIndex]));");
                    source.AppendLine($"        }}");
                }
            }
            source.AppendLine("    }");
            source.AppendLine();
            // PartialClear
            source.AppendLine("    public void PartialClear(GameTimelinePlayer timelinePlayer, int resourceId)");
            source.AppendLine("    {");
            foreach (var valueType in eventDataTypes)
            {
                if(valueType == string.Empty) continue;
                source.AppendLine($"        _{TitleLower(valueType)}Values.Clear();");
            }
            source.AppendLine("     }");
            source.AppendLine("}");

            context.AddSource("TimelineNodeEventController.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        }

        private string TitleUpper(string input)
        {
            return char.ToUpper(input[0]) + input.Substring(1);
        }

        private string TitleLower(string input)
        {
            return char.ToLower(input[0]) + input.Substring(1);
        }
        class SyntaxReceiver : ISyntaxReceiver
        {
            public List<string> EventTypes { get; } = new();
            public List<string> EventDataTypes { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is RecordDeclarationSyntax recordDecl)
                {
                    var interfaces = recordDecl.BaseList?.Types;
                    if (interfaces == null) return;

                    bool implementsIGameTimelineEvent = false;
                    string? eventDataType = null;

                    foreach (var baseType in interfaces)
                    {
                        // 直接实现 IGameTimelineEvent
                        if (baseType.Type is SimpleNameSyntax simpleName &&
                            simpleName.Identifier.Text == "IGameTimelineEvent")
                        {
                            implementsIGameTimelineEvent = true;
                            break;
                        }

                        // 处理泛型接口 IGameTimelineEventData<T>
                        if (baseType.Type is GenericNameSyntax genericName &&
                            genericName.Identifier.Text == "IGameTimelineEventData" &&
                            genericName.TypeArgumentList.Arguments.Count == 1)
                        {
                            implementsIGameTimelineEvent = true;
                            eventDataType = genericName.TypeArgumentList.Arguments[0].ToString();
                        }
                    }

                    if (!implementsIGameTimelineEvent) return;

                    string typeName = recordDecl.Identifier.Text;
                    if (EventTypes.Contains(typeName)) return;

                    EventTypes.Add(typeName);
                    EventDataTypes.Add(eventDataType ?? string.Empty);
                }
            }
        }
    }
}
