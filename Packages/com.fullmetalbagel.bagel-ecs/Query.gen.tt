<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace RelEcs
{
<# GenerateQuery(10); #>

}

<#+
    void GenerateQuery(int maxTypeCount)
    {
        for (var count = 2; count < maxTypeCount; count++)
        {
            var indices = Enumerable.Range(0, count);
            var typeNames = indices.Select(i => $"C{i}");
            var genericTypes = string.Join(", ", typeNames);
            var classRestricts = string.Join(Environment.NewLine, typeNames.Select(type => $"        where {type} : class"));
            var getStorageArrays = string.Join(Environment.NewLine, typeNames.Select(type => $"                table.GetStorage<{type}>(Identity.None),"));
            var returnStorages = string.Join(", ", indices.Select(i => $"((C{i}[])storages[{i}])[meta.Row]"));
            var returnEnumeratorCurrent = string.Join(", ", indices.Select(i => $"_data.Tables[_data.TableIndex].GetStorage<C{i}>(Identity.None)[_data.EntityIndex]"));
            var buildHas = string.Join(".", typeNames.Select(type => $"Has<{type}>()"));
#>

    public class Query<<#= genericTypes #>> : Query
<#= classRestricts #>
    {
        public Query(Archetypes archetypes, Mask mask, List<Table> tables) : base(archetypes, mask, tables)
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override Array[] GetStorages(Table table)
        {
            return new Array[]
            {
<#= getStorageArrays #>
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public (<#= genericTypes #>) Get(Entity entity)
        {
            var meta = Archetypes.GetEntityMeta(entity.Identity);
            var storages = Storages[meta.TableId];
            return (<#= returnStorages #>);
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(Tables);
        }

        public ref struct Enumerator
        {
            private QueryEnumerator _data;
            public Enumerator(IReadOnlyList<Table> tables) => _data = new QueryEnumerator(tables);
            public bool MoveNext() => _data.MoveNext();
            public (<#= genericTypes #>) Current => (<#= returnEnumeratorCurrent #>);
        }

        public sealed class Builder : QueryBuilder
        {
            static readonly Func<Archetypes, Mask, List<Table>, Query> CreateQuery =
                (archetypes, mask, matchingTables) => new Query<<#= genericTypes #>>(archetypes, mask, matchingTables);

            public Builder(Archetypes archetypes) : base(archetypes)
            {
                <#= buildHas #>;
            }

            public new Builder Has<T>(Entity? target = default)
            {
                return (Builder)base.Has<T>(target);
            }

            public new Builder Has<T>(Type type)
            {
                return (Builder)base.Has<T>(type);
            }

            public new Builder Not<T>(Entity? target = default)
            {
                return (Builder)base.Not<T>(target);
            }

            public new Builder Not<T>(Type type)
            {
                return (Builder)base.Not<T>(type);
            }

            public new Builder Any<T>(Entity? target = default)
            {
                return (Builder)base.Any<T>(target);
            }

            public new Builder Any<T>(Type type)
            {
                return (Builder)base.Any<T>(type);
            }

            public Query<<#= genericTypes #>> Build()
            {
                return (Query<<#= genericTypes #>>)Archetypes.GetQuery(Mask, CreateQuery);
            }
        }
    }

    public static partial class WorldQueryExtension
    {
        public static Query<<#= genericTypes #>>.Builder Query<<#= genericTypes #>>(this World world)
<#= classRestricts #>
        {
            return new Query<<#= genericTypes #>>.Builder(world._archetypes);
        }
    }
<#+
        }
    }
#>
